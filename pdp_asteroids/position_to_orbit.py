import os
from pathlib import Path
from typing import Optional, Tuple, Sequence, Union, Literal

import numpy as np
import numpy.typing as npt
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
import matplotlib.animation as animation
from astropy.time import Time
from astropy.io import fits
from astropy.io.fits import HDUList


FILE_DIR = Path(os.path.dirname(os.path.abspath(__file__)))

def xy_to_rthet(x: np.ndarray, y: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
    """Convert Cartesian (x, y) coordinates to polar (r, θ) coordinates.

    This function transforms 2D Cartesian coordinates into polar coordinates,
    where the angle θ is normalized to be within the range [0, 2π].

    Args:
        x (np.ndarray): Array of x-coordinates
        y (np.ndarray): Array of y-coordinates

    Returns:
        tuple[np.ndarray, np.ndarray]: A tuple containing:
            - r (np.ndarray): Array of radial distances from origin
            - theta (np.ndarray): Array of angles in radians, range [0, 2π]

    Note:
        - Input arrays must be broadcastable to the same shape
        - The angle is measured counterclockwise from the positive x-axis
        - Uses numpy's arctan2 for correct quadrant handling

    Example:
        >>> x = np.array([1, 1/np.sqrt(2), 0])
        >>> y = np.array([0, 1/np.sqrt(2), 1])
        >>> r, theta = xy_to_rthet(x, y)
        >>> print(r)  # array([1., 1., 1.])
        >>> print(theta)  # array([0., π/4, π/2])
    """
    r = np.sqrt(x**2 + y**2)
    theta = np.arctan2(y, x)
    theta[theta<0]+=2*np.pi
    return r, theta

def rthet_to_xy(r: np.ndarray, theta: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
    """Convert polar (r, θ) coordinates to Cartesian (x, y) coordinates.

    This function transforms polar coordinates into 2D Cartesian coordinates
    using the standard transformation equations:
    x = r cos(θ)
    y = r sin(θ)

    Args:
        r (np.ndarray): Array of radial distances from origin
        theta (np.ndarray): Array of angles in radians

    Returns:
        tuple[np.ndarray, np.ndarray]: A tuple containing:
            - x (np.ndarray): Array of x-coordinates
            - y (np.ndarray): Array of y-coordinates

    Note:
        - Input arrays must be broadcastable to the same shape
        - Assumes angles are in radians
        - The function works with both positive and negative angles

    Example:
        >>> r = np.array([1., 1., 1.])
        >>> theta = np.array([0., np.pi/4, np.pi/2])
        >>> x, y = rthet_to_xy(r, theta)
        >>> print(x)  # array([1., 0.707.., 0.])
        >>> print(y)  # array([0., 0.707.., 1.])
    """
    x = r*np.cos(theta)
    y = r*np.sin(theta)
    return x, y

def solve_kepler(mobs: np.ndarray, e: float, order: int = 100) -> np.ndarray:
    """Solve Kepler's equation using fixed-point iteration.

    Solves the equation M = E - e*sin(E) for eccentric anomaly E,
    given mean anomaly M and eccentricity e. Uses the iterative method:
    E_{n+1} = M + e*sin(E_n)

    Args:
        mobs (np.ndarray): Array of mean anomalies M in radians
        e (float): Orbital eccentricity (0 ≤ e < 1)
        order (int, optional): Number of iterations for convergence. 
            Defaults to 100.

    Returns:
        np.ndarray: Array of eccentric anomalies E in radians

    Note:
        - Convergence is guaranteed for e < 1
        - The number of iterations needed for convergence increases with e
        - For nearly parabolic orbits (e ≈ 1), more iterations may be needed
        - Initial guess is E_0 = M

    Example:
        >>> M = np.array([0., np.pi/2, np.pi])
        >>> e = 0.1
        >>> E = solve_kepler(M, e)
        >>> np.all(np.abs(E - M - e*np.sin(E)) < 1e-6)  # True

    References (generated by Claude, hopefully not hallucinations):
        For details on Kepler's equation and solution methods, see:
        - Murray & Dermott "Solar System Dynamics", Chapter 2
        - Vallado "Fundamentals of Astrodynamics and Applications", Chapter 2
    """
    Eobs = np.copy(mobs)
    for _ in range(1,order+1):
        Eobs = mobs + e*np.sin(Eobs)
    return Eobs

def make_orbit(
    times: np.ndarray,
    phase0: float,
    a: float,
    e: float,
    omega: float
) -> tuple[np.ndarray, np.ndarray]:
    """Calculate orbital positions at specified times for a Keplerian orbit.

    Computes the radial distances and orbital angles for an object in a
    Keplerian orbit around the Sun, given orbital elements and observation times.
    Uses the numerically stable tangent half-angle formula for computing
    true anomaly from eccentric anomaly.

    Args:
        times (np.ndarray): Array of observation times in Julian Days
        phase0 (float): Initial orbital phase in cycles
        a (float): Semi-major axis in AU
        e (float): Eccentricity (0 ≤ e < 1)
        omega (float): Argument of perihelion in radians

    Returns:
        tuple[np.ndarray, np.ndarray]: A tuple containing:
            - radii (np.ndarray): Array of radial distances in AU
            - angles (np.ndarray): Array of orbital angles in radians [0, 2π]

    Note:
        - Period is calculated using Kepler's Third Law
        - All angles are in radians
        - The orbital period assumes 365.25 days per year
        - Phase0 represents the orbital phase at the first observation time
        - The returned angle is the true anomaly plus omega, normalized to [0, 2π]
    """
    period = np.sqrt(a**3) * 365.25
    mean_anomaly = 2 * np.pi * (phase0 + (times - 0) / period)
    eccentric_anomaly = solve_kepler(mean_anomaly, e)
    
    # Convert eccentric anomaly to true anomaly using the tangent half-angle formula
    beta = e / (1 + np.sqrt(1 - e**2))
    true_anomaly = eccentric_anomaly + 2 * np.arctan(
        beta * np.sin(eccentric_anomaly) / (1 - beta * np.cos(eccentric_anomaly))
    )
    
    # Calculate radial distances using the orbit equation
    radii = a * (1 - e**2) / (1 + e * np.cos(true_anomaly))

    # Add omega and normalize angles to [0, 2π]
    angles = (true_anomaly + omega) % (2 * np.pi)

    return radii, angles

def parallax_to_dist(
    coords1: tuple[float, float],
    err1: tuple[float, float],
    coords2: tuple[float, float],
    err2: tuple[float, float],
    dt: float,
    true_error_propagation: bool = False
) -> tuple[float, float]:
    """Calculate distance from parallax measurements between two observations.

    Computes the distance to an object using parallax measurements from two
    observations separated by a known time interval. Uses Earth's orbital motion
    as the baseline for parallax measurement.

    Args:
        coords1 (tuple[float, float]): First position (RA, Dec) in degrees
        err1 (tuple[float, float]): Uncertainties in first position (σRA, σDec)
        coords2 (tuple[float, float]): Second position (RA, Dec) in degrees
        err2 (tuple[float, float]): Uncertainties in second position (σRA, σDec)
        dt (float): Time difference between observations in days
        true_error_propagation (bool, optional): If True, uses full error
            propagation instead of simple percentage error. Currently not
            implemented. Defaults to False.

    Returns:
        tuple[float, float]: A tuple containing:
            - dist (float): Distance to object in AU
            - dist_err (float): Uncertainty in distance in AU

    Note:
        - Input coordinates must be in degrees
        - Uses Earth's orbital period of 365.25 days
        - When true_error_propagation=False, assumes 5% distance uncertainty
        - Baseline is calculated as sin(θ/2) where θ is Earth's orbital angle
          between observations

    Raises:
        NotImplementedError: If true_error_propagation=True

    Example:
        >>> coords1 = (180.0, 20.0)  # RA, Dec for first observation
        >>> coords2 = (180.1, 20.1)  # RA, Dec for second observation
        >>> err1 = err2 = (0.001, 0.001)  # Uncertainties
        >>> dist, dist_err = parallax_to_dist(coords1, err1, coords2, err2, 4.0)
    """
    
    # Calculate Earth's orbital angle and baseline
    theta_earth = 2 * np.pi * dt / 365.25
    baseline = np.sin(theta_earth / 2.)  # AU

    # Extract coordinates
    ra1, d1 = coords1
    ra2, d2 = coords2

    # Calculate parallax angle in degrees
    parallax = np.sqrt((ra1 - ra2)**2 + (d1 - d2)**2)
    
    # Convert distance using small angle approximation
    dist = baseline / np.sin(parallax * np.pi / 180.)

    if true_error_propagation:
        raise NotImplementedError("""
        Full error propagation is not yet implemented. The method would be:
        
        # Calculate combined coordinate uncertainties
        dra = np.sqrt((e1[0]**2 + e2[0]**2))
        ddec = np.sqrt((e1[1]**2 + e2[1]**2))
        
        # Propagate to parallax uncertainty
        parallax_err = np.sqrt(
            (ra1-ra2)**2/parallax**2 * dra**2 + 
            (d1-d2)**2/parallax**2 * ddec**2
        )
        
        # Convert to angular uncertainty
        sinp_err = np.sqrt(
            np.cos(parallax*np.pi/180.)*parallax_err*np.pi/180.
        )
        
        # Final distance uncertainty
        dist_err = dist * sinp_err/np.sin(parallax*np.pi/180.)
        """)
    else:
        # Use simple 3% distance uncertainty
        dist_err = 0.03 * dist

    return dist, dist_err

def dist_to_parallax(
    time: float,
    r: float,
    theta: float,
    dt: float
) -> tuple[float, float]:
    """Calculate expected parallax and solar elongation for an object's position.

    Given an object's position in polar coordinates and observation timing,
    computes the expected parallax angle and solar elongation. This is
    effectively the inverse of parallax_to_dist().

    Args:
        time (float): Observation time in Julian Days
        r (float): Object's distance from Sun in AU
        theta (float): Object's angular position in radians
        dt (float): Time difference between observations in days

    Returns:
        tuple[float, float]: A tuple containing:
            - parallax (float): Expected parallax angle in arcseconds
            - sin_sun (float): Sine of the solar elongation angle

    Note:
        - Uses JD 2460392.400856 as the reference epoch
        - Assumes Earth's orbit is circular with radius 1 AU
        - Converts output parallax from radians to arcseconds (x206265)
        - Solar elongation is returned as sin(angle) for efficiency
        - Earth's orbital period is assumed to be 365.25 days

    Example:
        >>> time = 2460393.5  # Julian Date
        >>> r = 2.5  # AU
        >>> theta = np.pi/4  # radians
        >>> dt = 4.0  # days
        >>> parallax, sin_sun = dist_to_parallax(time, r, theta, dt)
    """
    # Calculate Earth's position at observation time
    REFERENCE_JD = 2460392.400856  # Reference Julian Date
    RAD_TO_ARCSEC = 206265.0  # Conversion factor
    
    theta_earth = 2 * np.pi / 365.25 * (time - REFERENCE_JD)
    r_earth = 1  # Earth's orbital radius in AU
    
    # Convert positions to Cartesian coordinates
    xe, ye = rthet_to_xy(r_earth, theta_earth)  # Earth's position
    xa, ya = rthet_to_xy(r, theta)  # Asteroid's position
    
    # Calculate Earth-asteroid distance
    distance = np.sqrt((xe - xa)**2 + (ye - ya)**2)

    # Calculate parallax angle
    dtheta = dt * 2 * np.pi / 365.25
    baseline = np.sin(dtheta / 2)  # Baseline in AU
    parallax = np.arcsin(baseline / distance)  # in radians
    print(f"{distance=}, {parallax=} radians")

    # Calculate solar elongation
    sin_sun = r / distance * np.sin(theta - theta_earth)

    return parallax * RAD_TO_ARCSEC, sin_sun

def dist_to_r(
    time: float,
    theta: float,
    elong: float,
    dist: float,
    dist_err: float
) -> tuple[float, float]:
    """Convert geocentric distance to heliocentric distance.

    Calculates an object's distance from the Sun given its distance from Earth,
    angular position, and solar elongation. Uses the law of sines to relate
    Earth-object distance to Sun-object distance.

    Args:
        time (float): Observation time in Julian Days
        theta (float): Object's angular position in radians
        elong (float): Sine of the solar elongation angle
        dist (float): Distance from Earth to object in AU
        dist_err (float): Uncertainty in Earth-object distance in AU

    Returns:
        tuple[float, float]: A tuple containing:
            - r (float): Distance from Sun to object in AU
            - r_err (float): Uncertainty in Sun-object distance in AU

    Note:
        - Uses JD 2460392.400856 as the reference epoch
        - Assumes Earth's orbit is circular with radius 1 AU
        - Input elongation should be sine of the angle
        - Uses error propagation assuming error only in distance
        - Earth's orbital period is assumed to be 365.25 days
        
    Warning:
        Function can be unstable when sin(theta - theta_earth) is close to zero,
        i.e., when the object is near conjunction or opposition.

    Example:
        >>> time = 2460393.5  # Julian Date
        >>> theta = np.pi/4  # radians
        >>> elong = 0.7  # sine of elongation angle
        >>> dist = 2.0  # AU
        >>> dist_err = 0.1  # AU
        >>> r, r_err = dist_to_r(time, theta, elong, dist, dist_err)

    Todo:
        Consider reimplementing using vector addition for better numerical
        stability and clarity.
    """
    # Calculate Earth's angular position
    REFERENCE_JD = 2460392.400856
    theta_earth = 2 * np.pi / 365.25 * (time - REFERENCE_JD)

    # Calculate heliocentric distance using law of sines
    angle_diff = theta - theta_earth
    r = dist * elong / np.sin(angle_diff)
    
    # Propagate distance error
    r_err = dist_err * elong / np.sin(angle_diff)

    return r, r_err

def Gauss2D(
    x: np.ndarray,
    y: np.ndarray,
    amp: float,
    x0: float,
    y0: float,
    sigx: float,
    sigy: float,
    rot: float = 0
) -> np.ndarray:
    """Calculate a 2D Gaussian function with optional rotation.

    Implements a generalized 2D Gaussian function of the form:
    f(x,y) = amp * exp(-[a(x-x0)² + 2b(x-x0)(y-y0) + c(y-y0)²])
    where a, b, c are coefficients determined by the rotation and sigmas.

    Args:
        x (np.ndarray): x coordinates (meshgrid)
        y (np.ndarray): y coordinates (meshgrid)
        amp (float): Amplitude of the Gaussian
        x0 (float): Center x coordinate
        y0 (float): Center y coordinate
        sigx (float): Standard deviation in x direction
        sigy (float): Standard deviation in y direction
        rot (float, optional): Rotation angle in radians. Defaults to 0.

    Returns:
        np.ndarray: 2D array of Gaussian values

    Note:
        - The rotation is counterclockwise
        - x and y should be generated using np.meshgrid
        - The function handles arbitrary aspect ratios (sigx ≠ sigy)
        - For an unrotated Gaussian, set rot=0

    Example:
        >>> x, y = np.meshgrid(np.linspace(-5, 5, 100), np.linspace(-5, 5, 100))
        >>> gauss = Gauss2D(x, y, amp=1.0, x0=0, y0=0, sigx=1, sigy=2, rot=np.pi/4)

    References:
        For the mathematical derivation, see:
        https://en.wikipedia.org/wiki/Gaussian_function#Two-dimensional_Gaussian_function
    """
    # Calculate the coefficients for the rotated Gaussian
    a = np.cos(rot)**2 / (2 * sigx**2) + np.sin(rot)**2 / (2 * sigy**2)
    b = np.sin(2 * rot) / (2 * sigx**2) - np.sin(2 * rot) / (2 * sigy**2)
    c = np.sin(rot)**2 / (2 * sigx**2) + np.cos(rot)**2 / (2 * sigy**2)

    # Calculate the Gaussian using the quadratic form
    return amp * np.exp(-a * (x - x0)**2 - b * (x - x0) * (y - y0) - c * (y - y0)**2)

def inject_asteroid(
    hdulst: HDUList,
    parallax: float,
    obsdate: str,
    obsdelta: float,
    jd: float,
    theta: float,
    sin_sun: float,
    fwhm: float,
    fluxlevel: float,
    noiselevel: float,
    output_str: str,
    output_dir: Path = FILE_DIR
) -> Tuple[np.ndarray, np.ndarray, Path, Path]:
    """Inject a synthetic moving asteroid into a pair of astronomical images.

    This function creates two synthetic images of a moving asteroid by injecting
    a Gaussian PSF (Point Spread Function) into a base astronomical image. The
    asteroid's position changes between the two images to simulate proper motion
    and parallax effects.

    Args:
        hdulst: FITS HDU list containing the base image and header
        parallax: Parallax angle in arcseconds
        obsdate: Observation date string (format: YYYY-MM-DD)
        obsdelta: Time difference between frames in days
        jd: Julian Date of the observation
        theta: Angular position in radians
        sin_sun: Sine of the solar elongation angle
        fwhm: Full Width at Half Maximum for the Gaussian PSF in pixels
        fluxlevel: Brightness percentile in the image to set PSF amplitude
        noiselevel: Standard deviation of additional Gaussian noise
        output_str: String identifier for output filenames
        output_dir: Directory to save output FITS files (default: FILE_DIR)

    Returns:
        Tuple containing:
            - First image array with injected asteroid
            - Second image array with injected asteroid
            - Path to first output FITS file
            - Path to second output FITS file

    Notes:
        - The function randomly flips the base image to increase variety
        - PSF position is randomly chosen but constrained to avoid image edges
        - Photon noise is simulated using Poisson statistics
        - PSF shape includes random variations in size and orientation
        - Output images are saved as FITS files with updated headers
        - Image coordinates use the FITS standard convention
        - The asteroid's position shift between frames is consistent with the
          specified parallax angle

    Example:
        >>> from astropy.io import fits
        >>> hdul = fits.open('base_image.fits')
        >>> im1, im2, f1, f2 = inject_asteroid(
        ...     hdul, 10.0, '2024-01-01', 0.25, 2460000.0, 
        ...     1.5, 0.5, 3.0, 95.0, 0.1, 'test'
        ... )
        >>> print(f"Files saved to: {f1}, {f2}")
    """
    ### Decide where to add inital PSF
    data = hdulst[0].data
    data[np.isnan(data)] = 3.
    ### Randomly flip the data around
    if np.random.uniform(0,1) > 0.5:
        data = data[::-1,:]
    if np.random.uniform(0,1) > 0.5:
        data = data[:,::-1]

    header = hdulst[0].header
    header.append(('obsdt',obsdelta,'Time in hours'),end=True)
    header.append(('jd', jd, 'Julian date'),end=True)
    header.append(('theta', theta, 'angle'),end=True)
    header.append(('elong', sin_sun, 'sin solar elongation'),end=True)
    header['CD2_1'] = 0.
    header['CD1_2'] = 0.
    # plt.imshow(data,vmin=np.nanpercentile(data,5),vmax=np.nanpercentile(data,95))
    # plt.show()

    ### Get coordinate info in degrees
    ra0, dec0 = header['CRVAL1'], header['CRVAL2']
    dra, ddec = header['CD2_2'], header['CD1_1']
    x0, y0 = header['CRPIX2'], header['CRPIX1']

    ### Decide where to add the first PSF
    x1, y1 = np.random.randint(200, data.shape[1]-200), np.random.randint(200, data.shape[0]-200)
    ### Decide where to add the second PSF, making sure the offset gives the right parallax
    d2 = (parallax/3600.)**2
    ### Make sure we generate values in the image, away from edge effects
    # print(x1, y1, np.sqrt(d2)/dra)
    x2, y2 = -100, -100
    while x2 < 100 or y2 < 100 or x2 > 900 or y2 > 900:
        dx = np.random.uniform(low=-np.sqrt(d2),high=np.sqrt(d2))
        dy = np.sqrt(d2-dx**2)
        ### Randomize y offset sign
        if np.random.uniform(0,1) > 0.5: dy*=-1
        ### Convert to pixels and apply offset
        x2, y2 = x1+dx/dra, y1+dy/ddec
    # print(x1,x2, y1,y2)

    ### Now we actually add the PSFs to the images
    x, y = np.meshgrid(np.arange(data.shape[0]),np.arange(data.shape[1]))
    rot = np.random.uniform(0,2*np.pi)
    sigx, sigy = np.random.normal(fwhm,0.5), np.random.normal(fwhm,0.5)
    amp = np.nanpercentile(data,fluxlevel)
    psf1 = Gauss2D(x,y, amp, x1,y1,sigx,sigy,rot)
    psf2 = Gauss2D(x,y, amp, x2,y2,sigx,sigy,rot)

    ### Add PSFs to image
    im1 = data+psf1
    im2 = data+psf2
    ### Add photon noise
    im1 += np.random.normal(np.sqrt(np.abs(im1))) + np.random.normal(loc=0,scale=noiselevel,size=im1.shape)
    im2 += np.random.normal(np.sqrt(np.abs(im2))) + np.random.normal(loc=0,scale=noiselevel,size=im1.shape)

    # plt.imshow(im1-im2,vmin=-np.nanpercentile(data,10),vmax=np.nanpercentile(data,10))
    # plt.show()
    
    ### Write to disk
    # out_dir = output_dir/'injected_images'/output_str
    output_dir.mkdir(exist_ok=True, parents=True)
    # out_dir.mkdir(exist_ok=True, parents=True)

    fname1 = output_dir/(obsdate+'_'+output_str+'_frame1.fits')
    fname2 = output_dir/(obsdate+'_'+output_str+'_frame2.fits')
    fits.writeto(fname1, data=im1, header=header, overwrite=True)
    fits.writeto(fname2, data=im2, header=header, overwrite=True)


    ### Return two image arrays
    return im1, im2, fname1, fname2

def prior_transform(
    u: Union[Sequence[float], npt.NDArray[np.float64]],
    phase0: Sequence[float],
    a: Sequence[float],
    e: Sequence[float],
    omega: Sequence[float]
) -> npt.NDArray[np.float64]:
    """Transform unit hypercube parameters to physical orbital parameters.

    This function implements the prior transformation for nested sampling,
    converting parameters from the unit hypercube [0,1] to their physical
    ranges for orbital fitting. It handles the following orbital parameters:
    phase0 (orbital phase), a (semi-major axis), e (eccentricity), and
    omega (argument of perihelion).

    Args:
        u: Unit hypercube parameters, array-like of length 4 with values in [0,1]
        phase0: [min, max] range for initial orbital phase
        a: [min, max] range for semi-major axis in AU
        e: [min, max] range for eccentricity
        omega: [min, max] range for argument of perihelion in units of 2π

    Returns:
        Array of transformed parameters in physical units:
            - x[0]: orbital phase in range [phase0_min, phase0_max]
            - x[1]: semi-major axis in range [a_min, a_max] AU
            - x[2]: eccentricity in range [e_min, e_max]
            - x[3]: argument of perihelion in range [omega_min, omega_max]*2π rad

    Notes:
        - The transformation is linear for each parameter
        - Omega is scaled by 2π to convert to radians
        - Input ranges should be physically meaningful:
            * phase0: typically [0, 1]
            * a: positive values, e.g., [0.4, 40] AU
            * e: [0, 1) for bound orbits
            * omega: typically [0, 1] for full 2π range

    Example:
        >>> u = np.array([0.5, 0.5, 0.5, 0.5])
        >>> phase0 = [0, 1]
        >>> a = [0.4, 40]
        >>> e = [0, 0.99]
        >>> omega = [0, 1]
        >>> x = prior_transform(u, phase0, a, e, omega)
        >>> print(f"Transformed parameters: {x}")
    """
    x = np.array(u)
    x[0] = u[0]*(phase0[1]-phase0[0])+phase0[0]

    ### a
    x[1] = u[1]*(a[1]-a[0])+a[0]

    ### e
    x[2] = u[2]*(e[1]-e[0])+e[0]

    ### omega
    x[3] = 2*np.pi*u[3]*(omega[1]-omega[0])+omega[0]

    ### Tperi
    #period = np.sqrt(x[1]**3)*365.25
    # x[0] = period - period/2.
    

    return x

from dataclasses import dataclass
from typing import Sequence, Union
import numpy as np
import numpy.typing as npt


@dataclass
class Prior:
    """A callable prior distribution for orbital parameters.
    
    This class represents a prior distribution for nested sampling of orbital
    parameters. It stores the ranges for each parameter and provides a callable
    interface to transform unit hypercube values to physical parameter space.
    
    Attributes:
        phase0: [min, max] range for initial orbital phase
        a: [min, max] range for semi-major axis in AU
        e: [min, max] range for eccentricity
        omega: [min, max] range for argument of perihelion in units of 2π

    Example:
        >>> prior = Prior(
        ...     phase0=[0, 1],
        ...     a=[0.4, 40],
        ...     e=[0, 0.99],
        ...     omega=[0, 1]
        ... )
        >>> u = np.array([0.5, 0.5, 0.5, 0.5])
        >>> x = prior(u)  # Transforms parameters to physical space
    """
    phase0: Sequence[float]
    a: Sequence[float]
    e: Sequence[float]
    omega: Sequence[float]

    def __call__(
        self, 
        x: Union[Sequence[float], npt.NDArray[np.float64]]
    ) -> npt.NDArray[np.float64]:
        return prior_transform(x, self.phase0, self.a, self.e, self.omega)



def loglike(
    x: Union[Sequence[float], npt.NDArray[np.float64]],
    times: Union[Sequence[float], npt.NDArray[np.float64]],
    rs: Union[Sequence[float], npt.NDArray[np.float64]],
    rerrs: Union[Sequence[float], npt.NDArray[np.float64]],
    thetas: Union[Sequence[float], npt.NDArray[np.float64]],
    thetaerrs: Union[Sequence[float], npt.NDArray[np.float64]]
) -> float:
    """Calculate the log-likelihood for orbital parameter fitting.

    This function computes the log-likelihood of orbital parameters given
    observed positions and their uncertainties. It fits orbits in Cartesian
    coordinates by comparing the observed and predicted x and y positions.

    Args:
        x: Orbital parameters array [phase0, a, e, omega] where:
            - phase0: initial orbital phase
            - a: semi-major axis in AU
            - e: eccentricity
            - omega: argument of perihelion in radians
        times: Observation times in Julian Days
        rs: Observed radial distances from Sun in AU
        rerrs: Uncertainties in radial distances
        thetas: Observed angular positions in radians
        thetaerrs: Uncertainties in angular positions (unused in current impl)

    Returns:
        Log-likelihood value. More negative values indicate worse fits,
        while values closer to zero indicate better fits.

    Notes:
        - The implementation uses Cartesian coordinates (x,y) for the fit
        - The likelihood assumes Gaussian uncertainties
        - Current implementation uses rerrs for both x and y components
        - An alternative implementation using polar coordinates is commented out
        - The negative sign makes this suitable for minimization

    Example:
        >>> x = np.array([0.5, 2.0, 0.1, np.pi/2])  # Orbital parameters
        >>> times = np.array([2460000.0, 2460010.0])  # Julian dates
        >>> rs = np.array([1.5, 1.6])  # Observed distances
        >>> rerrs = np.array([0.1, 0.1])  # Uncertainties
        >>> thetas = np.array([0.1, 0.2])  # Observed angles
        >>> thetaerrs = np.array([0.01, 0.01])  # Angular uncertainties
        >>> ll = loglike(x, times, rs, rerrs, thetas, thetaerrs)
    """
    # Calculate predicted orbit
    fitr, fittheta = make_orbit(times, x[0], x[1], x[2], x[3])
    
    # Convert both predicted and observed positions to Cartesian coordinates
    fitx, fity = rthet_to_xy(fitr, fittheta)
    obsx, obsy = rthet_to_xy(rs, thetas)

    # Calculate log-likelihood assuming Gaussian errors
    return -0.5 * np.sum((fitx-obsx)**2/rerrs**2) - 0.5*np.sum((fity-obsy)**2/rerrs**2)


@dataclass
class LogLikelihood:
    """A callable log-likelihood function for orbital parameter fitting.
    
    This class represents a log-likelihood function for nested sampling of 
    orbital parameters. It stores the observed data and measurement uncertainties,
    providing a callable interface for parameter optimization.
    
    Attributes:
        times: Observation times in Julian Days
        rs: Observed radial distances from Sun in AU
        rerrs: Uncertainties in radial distances
        thetas: Observed angular positions in radians
        thetaerrs: Uncertainties in angular positions

    Example:
        >>> times = np.array([2460000.0, 2460010.0])
        >>> rs = np.array([1.5, 1.6])
        >>> rerrs = np.array([0.1, 0.1])
        >>> thetas = np.array([0.1, 0.2])
        >>> thetaerrs = np.array([0.01, 0.01])
        >>> ll = LogLikelihood(times, rs, rerrs, thetas, thetaerrs)
        >>> x = np.array([0.5, 2.0, 0.1, np.pi/2])
        >>> log_likelihood = ll(x)  # Compute log-likelihood for parameters x
    """
    times: Union[Sequence[float], npt.NDArray[np.float64]]
    rs: Union[Sequence[float], npt.NDArray[np.float64]]
    rerrs: Union[Sequence[float], npt.NDArray[np.float64]]
    thetas: Union[Sequence[float], npt.NDArray[np.float64]]
    thetaerrs: Union[Sequence[float], npt.NDArray[np.float64]]

    def __call__(
        self, 
        x: Union[Sequence[float], npt.NDArray[np.float64]]
    ) -> float:
        return loglike(x, self.times, self.rs, self.rerrs, self.thetas, 
                      self.thetaerrs)


def run_fit(
   jds: Union[Sequence[float], npt.NDArray[np.float64]],
   rs_fit: Union[Sequence[float], npt.NDArray[np.float64]], 
   rs_err: Union[Sequence[float], npt.NDArray[np.float64]],
   thetas_fit: Union[Sequence[float], npt.NDArray[np.float64]], 
   thetas_err: Union[Sequence[float], npt.NDArray[np.float64]],
   sampler: Literal['dynesty', 'ultranest'] = 'dynesty',
   nlive: int = 100,
   dlogz: float = 0.5,
   bootstrap: int = 0,
   phase0: Sequence[float] = [0, 1],
   a: Sequence[float] = [0.4, 20],
   e: Sequence[float] = [0, 0.99],
   omega: Sequence[float] = [0, 1]
) -> npt.NDArray[np.float64]:
   """Fit orbital parameters using nested sampling.

   This function fits orbital parameters to observational data using either
   dynesty or ultranest nested sampling algorithms. It optimizes the orbital
   parameters by maximizing the likelihood of the observed positions given
   the model parameters.

   Args:
       jds: Observation times in Julian Days
       rs_fit: Observed radial distances from Sun in AU
       rs_err: Uncertainties in radial distances
       thetas_fit: Observed angular positions in radians
       thetas_err: Uncertainties in angular positions
       sampler: Nested sampling algorithm to use ('dynesty' or 'ultranest')
       nlive: Number of live points for nested sampling
       dlogz: Target evidence tolerance for convergence
       bootstrap: Number of bootstrap realizations (dynesty only)
       phase0: [min, max] range for initial orbital phase
       a: [min, max] range for semi-major axis in AU
       e: [min, max] range for eccentricity
       omega: [min, max] range for argument of perihelion in units of 2π

   Returns:
       Array of equally weighted posterior samples. Each row contains
       [phase0, a, e, omega] for a single sample.

   Notes:
       - Output directory is fixed to '/content/fit_results/'
       - dynesty's maxcall parameter is set to 200000
       - ultranest uses specific settings for improvement loops and updates
       - A commented implementation for pymultinest is maintained for reference

   Example:
       >>> times = np.array([2460000.0, 2460010.0])
       >>> rs = np.array([1.5, 1.6])
       >>> rs_errs = np.array([0.1, 0.1])
       >>> thetas = np.array([0.1, 0.2])
       >>> theta_errs = np.array([0.01, 0.01])
       >>> samples = run_fit(times, rs, rs_errs, thetas, theta_errs)
   """
   prefix = Path('/content/fit_results/')

   if sampler == 'dynesty':
       import dynesty
       loglike_func = LogLikelihood(jds, rs_fit, rs_err, thetas_fit, thetas_err)
       prior_func = Prior(phase0, a, e, omega)
       dsampler = dynesty.NestedSampler(
           loglike_func, 
           prior_func, 
           4,
           nlive=nlive,
           bootstrap=bootstrap
       )
       dsampler.run_nested(dlogz=dlogz, maxcall=200_000)
       res = dsampler.results
       return res.samples_equal()
   
   else:  # ultranest
       import ultranest
       prefix.mkdir(exist_ok=True, parents=True)
       
       loglike_func = LogLikelihood(jds, rs_fit, rs_err, thetas_fit, thetas_err)
       prior_func = Prior(phase0, a, e, omega)
       sampler = ultranest.ReactiveNestedSampler(
           ['phase0', 'a', 'e', 'omega'],
           loglike_func,
           prior_func,
           log_dir=str(prefix),
           resume='overwrite'
       )
       result = sampler.run(
           min_num_live_points=nlive,
           dlogz=dlogz,
           min_ess=nlive,
           update_interval_volume_fraction=0.4,
           max_num_improvement_loops=1
       )
       return result['samples']

   # Alternative implementation using pymultinest:
   # else:
   #     from pymultinest.solve import solve
   #     prefix.mkdir(exist_ok=True, parents=True)
   #     loglike_func = LogLikelihood(jds, rs_fit, rs_err, thetas_fit, thetas_err)
   #     result = solve(
   #         loglike_func, 
   #         prior_transform, 
   #         n_dims=4, 
   #         n_live_points=100,
   #         evidence_tolerance=0.5,
   #         outputfiles_basename=str(prefix),
   #         verbose=False, 
   #         resume=False
   #     )
   #     samples = np.genfromtxt(str(prefix/'post_equal_weights.dat'))[:,:-1]
   #     return samples

def make_images(
   obsdate: str,
   jd: float,
   r: float,
   theta: float,
   delta: float,
   image_list: Sequence[Union[str, Path]],
   output_str: str,
   fwhm: float = 3.5,
   fluxlevel: float = 50,
   noiselevel: float = 20,
   output_dir: Path = FILE_DIR
) -> Tuple[npt.NDArray[np.float64], npt.NDArray[np.float64], Path, Path]:
    """Create synthetic asteroid images from templates.

    This function generates a pair of astronomical images containing a synthetic
    moving asteroid. It calculates the expected parallax motion based on the
    orbital parameters, selects a random template image, and injects the
    synthetic asteroid with appropriate motion between frames.

    Args:
        obsdate: Observation date string (format: YYYY-MM-DD)
        jd: Julian Date of the observation
        r: Radial distance from Sun in AU
        theta: Angular position in radians
        delta: Time difference between frames in days
        image_list: List of paths to template FITS images
        output_str: String identifier for output filenames
        fwhm: Full Width at Half Maximum for the Gaussian PSF in pixels
            (default: 3.5)
        fluxlevel: Brightness percentile in the image to set PSF amplitude
            (default: 50)
        noiselevel: Standard deviation of additional Gaussian noise
            (default: 20)
        output_dir: Directory to save output FITS files (default: FILE_DIR)

    Returns:
        Tuple containing:
            - First image array with injected asteroid
            - Second image array with injected asteroid
            - Path to first output FITS file
            - Path to second output FITS file

    Notes:
        - Automatically calculates parallax and solar elongation from orbit
        - Randomly selects a template image from the provided list
        - Uses Earth's orbital period of 365.25 days for timing calculations
        - Injects asteroid with realistic position shift between frames
        - Creates FITS files with appropriate headers and WCS information

    Example:
        >>> import glob
        >>> templates = glob.glob('path/to/templates/*.fits')
        >>> im1, im2, f1, f2 = make_images(
        ...     '2024-01-01', 2460000.0, 2.5, np.pi/2, 0.25,
        ...     templates, 'test'
        ... )
        >>> print(f"Files saved to: {f1}, {f2}")
    """
    # Calculate parallax and solar elongation
    parallax, sin_sun = dist_to_parallax(jd, r, theta, delta)
    dtheta = delta * 2 * np.pi / 365.25
    baseline = np.sin(dtheta / 2)

    # Select random template image
    nimages = len(image_list)
    idx = np.random.randint(0, nimages)
    with fits.open(image_list[idx]) as hdulst:
        im1, im2, f1, f2 = inject_asteroid(
            hdulst, parallax, obsdate, delta, jd, theta, sin_sun,
            fwhm, fluxlevel, noiselevel, output_str, output_dir=output_dir
        )

    return im1, im2, f1, f2


def make_jds(dates: Sequence[str]) -> npt.NDArray[np.float64]:
    """Convert dates to Julian dates at noon UTC.
    
    Args:
        dates: Sequence of date strings in YYYY-MM-DD format
        
    Returns:
        Array of Julian dates for noon UTC on each input date
    """
    jds = []
    for date in dates:
        jds.append(Time(date+'T12:00:00', format='isot', scale='utc').jd)
    jds = np.asarray(jds)
    return jds


def plot_fit(
   dates: Sequence[str],
   rs_fit: Union[Sequence[float], npt.NDArray[np.float64]],
   thetas_fit: Union[Sequence[float], npt.NDArray[np.float64]],
   samples: npt.NDArray[np.float64],
   truths: Optional[Sequence[float]] = None,
   default_plot_period: float = 10
) -> Figure:
    """Create a polar plot of orbital fits with uncertainty.

    Generates a figure showing the fitted orbit(s), observed positions,
    and reference orbits for Earth and Jupiter. If provided, also shows
    the true orbit for comparison.

    Args:
        dates: Observation date strings
        rs_fit: Observed radial distances in AU
        thetas_fit: Observed angular positions in radians
        samples: MCMC/nested sampling posterior samples for orbital parameters
        truths: True orbital parameters [phase0, a, e, omega] if known
        default_plot_period: Default orbital period in years if truths not provided

    Returns:
        Matplotlib figure containing the orbital fit plot
    """
    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'},figsize=(10,10))
    ### Plot Earth

    ### Plot asteroid
    if truths is not None:
        a = truths[1]
        period = 365.25*np.sqrt(a**3)
        ptimes = np.linspace(0, 2*period,300)
        true_r, true_theta = make_orbit(ptimes, *truths)
        ax.plot(true_theta, true_r, color='k')
    else:
        period = default_plot_period*365.25 #years
    
    ptimes = np.linspace(0, 2*period,300)
    for i in range(200):
        rs, thetas = make_orbit(ptimes, *samples[i])
        if i!=0:
            ax.plot(thetas,rs,color='r',alpha=0.05)
        else:
            ax.plot(thetas,rs,color='r',alpha=0.05,label='Possible asteroid orbits')
    ax.plot(np.linspace(0,2*np.pi,100),np.ones(100),color='g',label='Earth\'s orbit')
    ax.plot(np.linspace(0,2*np.pi,100),5.2*np.ones(100),color='m',label='Jupiter\'s orbit')
    
    for i in range(len(rs_fit)):
        ax.scatter(thetas_fit[i], rs_fit[i], color='k',alpha=1.0,s=30,zorder=400)
        ax.text(thetas_fit[i]-2e-2,rs_fit[i]+1e-2,dates[i])
    ax.scatter(0,0,s=120,color='y',marker='*', label='Sun')

    ### Turn off axes ticks, set axis limits based on semi-major axis
    # ax.grid(False)
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    a_low, a_med, a_high = np.nanpercentile(samples[:,1], [0.05,0.5,0.95])
    rmax = 2*a_med+2*(a_high-a_med)
    if np.any(rs_fit < rmax) or rmax < 2.:
        rmax = 2*np.max(rs_fit)
        if rmax  < 2:
            rmax = 2.
    ax.set_rmax(rmax)
    ax.legend()

    ### print orbital period
    period = np.round(np.sqrt(a_med**3),2)
    errp_low = np.round(np.sqrt(a_med**3) - np.sqrt(a_low**3),2 )
    errp_high = np.round(np.sqrt(a_high**3) - np.sqrt(a_med**3),2)
    fig.text(0.1,0.8,r'Measured orbital period = '+str(period)+' +'+str(errp_low) + ' / -'+str(errp_high)+' years',fontsize=14)

    return fig


def calc_fit(
   rs_fit: Union[Sequence[float], npt.NDArray[np.float64]],
   thetas_fit: Union[Sequence[float], npt.NDArray[np.float64]],
   samples: npt.NDArray[np.float64],
   truths: Optional[Sequence[float]] = None,
   default_plot_period: float = 10
) -> Tuple[npt.NDArray[np.float64], npt.NDArray[np.float64]]:
    """Creates the data arrays to animate an orbit fit, with uncertainties.

    Generates arrays for the fitted orbit(s), observed positions,
    and reference orbits for Earth and Jupiter. If provided, also shows
    the true orbit for comparison.

    Args:
        rs_fit: Observed radial distances in AU
        thetas_fit: Observed angular positions in radians
        samples: MCMC/nested sampling posterior samples for orbital parameters
        truths: True orbital parameters [phase0, a, e, omega] if known
        default_plot_period: Default orbital period in years if truths not provided

    Returns:
        Numpy arrays for the times, posterior rs, posterior thetas, true rs, 
        true thetas, and orbital period (with errors)
    """

    ### Make true orbit, if given
    if truths is not None:
        a = truths[1]
        period = 365.25*np.sqrt(a**3)
        ptimes = np.linspace(0, 2*period,1000)
        true_r, true_theta = make_orbit(ptimes, *truths)
    else:
        period = default_plot_period*365.25 #years
        true_r, true_theta = np.array([]), np.array([])
    
    ### Make posterior draws
    ndraws = 50
    ptimes = np.linspace(0, 2*period,1000) 
    rs = np.empty((ndraws, ptimes.size))
    thetas = np.empty((ndraws, ptimes.size))
    for i in range(ndraws):
        rs[i], thetas[i] = make_orbit(ptimes, *samples[i])

    return ptimes, rs, thetas, true_r, true_theta

def plot_fit_animation(
   dates: Sequence[str],
   rs_fit: Union[Sequence[float], npt.NDArray[np.float64]],
   thetas_fit: Union[Sequence[float], npt.NDArray[np.float64]],
   samples: npt.NDArray[np.float64],
   truths: Optional[Sequence[float]] = None,
   default_plot_period: float = 3
) -> Figure:
    """Create a polar plot of orbital fits with uncertainty.

    Generates a figure showing the fitted orbit(s), observed positions,
    and reference orbits for Earth and Jupiter. If provided, also shows
    the true orbit for comparison.

    Args:
        dates: Observation date strings
        rs_fit: Observed radial distances in AU
        thetas_fit: Observed angular positions in radians
        samples: MCMC/nested sampling posterior samples for orbital parameters
        truths: True orbital parameters [phase0, a, e, omega] if known
        default_plot_period: Default orbital period in years if truths not provided

    Returns:
        Matplotlib animation containing the orbital fit plot
    """
    ### Make the arrays
    ptimes, rs, thetas, true_r, true_theta,= calc_fit(rs_fit, thetas_fit, samples, truths, default_plot_period)

    ### Get limits
    low, med, high = np.nanpercentile(samples, [0.05,0.5,0.95],axis=0)

    ### Make the initial figure
    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'},figsize=(10,10))
    ax.set_aspect('equal')
    ax.autoscale(enable=False)
    ax.axis('off')
    ax.grid(False)
    rmax = 2*med[1]+2*(high[1]-med[1])
    if np.any(rs_fit < rmax) or rmax < 2.:
        rmax = 2*np.max(rs_fit)
        if rmax  < 2:
            rmax = 2.
    ax.set_rmax(rmax)

    ### Draw Earth and Jupiter
    ax.plot(np.linspace(0,2*np.pi,100),np.ones(100),color='g',label='Earth\'s orbit')
    ax.plot(np.linspace(0,2*np.pi,100),5.2*np.ones(100),color='m',label='Jupiter\'s orbit')
    
    ### Draw observed points
    for i in range(len(rs_fit)):
        ax.scatter(thetas_fit[i], rs_fit[i], color='k',alpha=1.0,s=30,zorder=400)
        ax.text(thetas_fit[i]-2e-2,rs_fit[i]+1e-2,dates[i])
    ax.scatter(0,0,s=120,color='y',marker='*', label='Sun')
    ### Time placeholder
    dt = (ptimes[1]-ptimes[0])/365.25
    # print(ptimes)
    time_template = 'Date = %.1f'
    time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)

    ### Legend

    ### Text with orbital parameters 


    ### Set up objects for plotting
    ### FIXME add animation of Earth
    lines = []
    pts = []
    for i in range(rs.shape[0]):
        line, = ax.plot(0, 0,color='r',alpha=0.1)
        lines.append(line)
        pt, = ax.plot(0,0,'o',color='r')
        pts.append(pt)

    ### Animation loop
    def animate(i):
        for j,line in enumerate(lines):
            thisr = rs[j,:i]
            thistheta = thetas[j,:i]
            line.set_data(thistheta, thisr)
            # pt[j].set_data(thetas[j,i],rs[j,i])
            # ax.scatter(thetas[j,i],rs[j,i])
            #### Fix the date printing to be the actual date of the fitting epoch
            time_text.set_text(time_template % (i*dt + 2025))
        for j, pt in enumerate(pts):
            pt.set_data([thetas[j,i]],[rs[j,i]])
        return lines, time_text

    ### Actually make the animation
    ani = animation.FuncAnimation(fig,animate,ptimes.size,blit=True)
    plt.show()


    ### Return
    return ani

